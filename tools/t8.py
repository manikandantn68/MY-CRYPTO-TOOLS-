import binascii

c = 2205316413931134031074603746928247799030155221252519872650063628948700193645785517947578323929195613275812391565725176391984484116767211515666360482188604701858613934317828196821638422191523186931460211047129119943550415435824004862735461
n = 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673


def nth_root(x, n):
    # Start with some reasonable bounds around the nth root.
    upper_bound = 1
    while upper_bound ** n <= x:
        upper_bound *= 2
    lower_bound = upper_bound // 2

    # Binary search for the root
    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound) // 2
        mid_nth = mid ** n
        if mid_nth < x:
            lower_bound = mid + 1
        elif mid_nth > x:
            upper_bound = mid - 1
        else:
            return mid
    return lower_bound - 1

# Try small offsets to find a cube root that decodes to something meaningful
for i in range(4000):
    candidate = nth_root(c + i * n, 3)
    st = "{:x}".format(candidate)
    if "7069636f" in st:  # hex for 'pico'
        print(st)
        print(binascii.unhexlify(st))


